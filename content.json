{"meta":{"title":"子龙的博客","subtitle":"天下熙攘皆为利往 庙堂蝇营皆为名来","description":"","author":"子龙","url":"https://chengyijun.github.io","root":"/"},"pages":[{"title":"categories","text":"","path":"categories/index.html","date":"09-22","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"09-22","excerpt":""}],"posts":[{"title":"git第二次培训","text":"1 到底如何撤销 很多人问我 我到底该如何撤销某部分代码？这个要分不同的阶段来处理。 已经commit 可以通过git reset来回滚版本 12git reset --hard CommitIDgit reset --hard Head~ 还可以通过git revert来反做指定CommitID 1git revert CommitID 原理： git revert是用于“反做”某一个版本，以达到撤销该版本的修改的目的。比如，我们commit了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西。如下图所示： git revert 之后会形成一个新的提交 已经add 12git restore --staged .git restore --staged FileName 还未add 12git checkout .git checkout FileName 2 一个bug到底要修几次 我在dev分支已经修改某个bug了（或者别人已修复过该bug了），但是我还有功能没开发完，不能合并分支，线上又急需修复这个bug，我该怎么办，是去main 分支再修复一遍吗？ 12git checkout maingit cherry-pick c091b35 3 新功能开发了一半，如何去别的分支修bug 由于我当前所处的feature分支是不干净的（有未提交的内容），这时候是切换不了分支，拉取不了新内容的。 有三种应对方式： 丢弃当前分支上的新开发内容 （相当于这一部分白干） 将开发一半的功能进行提交 （由于开发没完成 可能导致程序跑不起来） 通过git stash 暂存当前分支的开发场景，让当前分支保持干净，处理完其他工作之后，可以通过git stash 恢复当前分支工作区状态 从stash恢复保存的工作区场景 12git stash apply stash@&#123;0&#125;git stash pop 从stash删除暂存 12git stash drop stash@&#123;0&#125;git stash clear 4 瞎写的提交备注怎么修改 很多人喜欢写一些无意义的提交备注 这非常不可取 这与不用版本管理无异 因为时间长了以后 你根本不知道该提交是什么 1git rebase -i Head~3 5 一个功能本地分了好几个提交，如何合并为一个完整提交 一个功能分好几个提交，push之后会让其他的合作开发人员感到费解，摸不着头脑，也不利于后期版本管理快速找到某一功能 1git rebase -i Head~3 6 push的时候，警告换行符问题 如果不管警告 push上去之后 协同开发的人员拉取下来，会影响他的代码比对 12345# 推荐配置# 提交检出均不转换git config --global core.autocrlf false# 允许提交包含混合换行符的文件git config --global core.safecrlf false 7 怎么样快速定位冲突 git mergetool 冲突发生后，通过这个工具，很快就能定位到冲突发生的地方 方便进行冲突解决 注意：解决玩冲突之后一定要提交，要不然git是不知道你已经解决了冲突的。 8 我.gitignore文件写晚了，已经提交并push了我不想被版本管理起来的文件 一些文件由于在加入.gitignore之前已经被提交和推送了，但是我又不能删掉本地的，怎么处理？ 比如：第三方库，临时编译文件，编译结果文件 123git ls-filesgit rm --cached FileNamegit rm -rf --cached DirName 9 分支模型和打标签主流的分支管理模型： 打标签 所谓Tag其实就是一种特殊的Branch，或者说是给某个CommitID取了个别名，主要作用为冻结版本，进行正式版本发布 1234# 查看标签git tag -l# 打标签git tag -a V1.0.5 -m &quot;V1.0.5正式版本&quot; 123# 向远端推送标签git tag push origin TagNamegit tag push origin --tags 123456789101112# 通过标签获取发版版本到新分支git checkout -b 新分支名 TagName# 根据标签打包git archive TagName --format=zip --output=V1.0.5.zip# 支持的打包格式git archive --listtartgztar.gzzip","path":"2023/05/17/git第二次培训/","date":"05-17","excerpt":"","tags":[]},{"title":"web调用exe","text":"创建 .reg 注册表文件 并使用管理员权限执行 1234567891011Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Webshell]@=&quot;URL:webshell Protocol Handler&quot;&quot;URL Protocol&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\\Webshell\\DefaultIcon]@=&quot;D:\\\\main.exe&quot;[HKEY_CLASSES_ROOT\\Webshell\\shell][HKEY_CLASSES_ROOT\\Webshell\\shell\\open][HKEY_CLASSES_ROOT\\Webshell\\shell\\open\\command]@=&quot;\\&quot;D:\\\\main.exe\\&quot; \\&quot;%1\\&quot;&quot; 只需要替换红线部分为目标exe路径 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;打开EXE&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;webshell://abel,rox,tank&quot;&gt; 打开main.exe &lt;/a&gt;&lt;/body&gt;&lt;/html&gt; main.py 生成 main.exe 做测试 1234import sysprint(&quot;传入的参数：&quot;, sys.argv)input(&quot;wait&quot;)","path":"2022/09/17/web调用exe/","date":"09-17","excerpt":"","tags":[]},{"title":"python上传文件","text":"1234567891011121314151617181920212223from pathlib import Pathfrom fastapi import FastAPI, UploadFile, Fileimport uvicornapp = FastAPI()@app.post(&quot;/upload&quot;)def test1(file: UploadFile = File()): # 这里的参数file必须与构建的file对象的key一致才行 print(file.filename) with open(f&quot;upload-&#123;file.filename&#125;&quot;, &quot;wb&quot;) as f: f.write(file.file.read()) return &#123;&quot;mes&quot;: &quot;ok&quot;&#125;if __name__ == &#x27;__main__&#x27;: uvicorn.run(app=f&quot;&#123;Path(__file__).name.split(&#x27;.&#x27;)[0]&#125;:app&quot;, host=&quot;localhost&quot;, port=3000, debug=True, reload=True, workers=1) 1234567import requests# 要上传的文件files = &#123;&#x27;file&#x27;: (&#x27;1.jpg&#x27;, open(&#x27;1.jpg&#x27;, &#x27;rb&#x27;), &quot;image/jpg&quot;)&#125;url = &quot;http://localhost:3000/upload&quot;r = requests.post(url, files=files)print(r.text)","path":"2022/09/09/python上传文件/","date":"09-09","excerpt":"","tags":[]},{"title":"supervisor+uwsgi+django","text":"配置静态文件相关设置123STATIC_URL = &#x27;/static/&#x27;STATICFILES_DIRS = [BASE_DIR.joinpath(&quot;app/static&quot;)]STATIC_ROOT = BASE_DIR.joinpath(&quot;static_all&quot;) 执行收集静态文件1python manage.py collectstatic 测试uwsgi运行1234# 两种形式都行（需要在指定的虚拟环境中执行）# 需要进入 manage.py 同级目录uwsgi --http :9985 --wsgi-file=project01/wsgi.py --static-map /static=static_alluwsgi --http :9985 --module=project01.wsgi --static-map /static=static_all 创建 uwsgi.ini 文件12345[uwsgi]http=0.0.0.0:9985wsgi-file=project01/wsgi.pystatic-map=/static=static_allvirtualenv=/root/.venvs/py39 通过uwsgi.ini文件启动12# 无需在虚拟环境中 因为uwsgi.ini 文件中已经指定了虚拟环境/usr/local/python39/bin/uwsgi --ini uwsgi.ini 安装supervisor1yum install epel-release supervisor -y 配置项目设置到supervisor12cd /etc/supervisord.d/vim pj01.ini 12345678[program:pj01]directory=/root/project01command=/usr/local/python39/bin/uwsgi --ini uwsgi.iniautostart=trueautorestart=falsestderr_logfile=/root/pj01/err.logstdout_logfile=/root/pj01/info.log#user = test 开启 supervisord1supervisord 开启supervisor Web服务（可选 非必须） 1vim /etc/supervisord.conf 12systemctl restart supervisordhttp://ip:9986 访问web控制页面 命令控制 pj01 123supervisorctl statussupervisorctl start pj01supervisorctl stop pj01 也可以使用单独的配置文件启动 supervisorvim looptest.conf 1234567891011[include]files=/etc/supervisord.conf[program:looptest] directory=/root/looptestcommand=python3 test.pyautostart=true autorestart=false stderr_logfile=/root/looptest/err.logstdout_logfile=/root/looptest/info.log#user = test 1supervisord -c looptest.conf","path":"2022/09/08/supervisor-uwsgi-django/","date":"09-08","excerpt":"","tags":[]},{"title":"webpack学习笔记","text":"123456789# 初始化项目 生成 package.json 文件npm init -y# 安装依赖npm i webpack webpack-cli -D# npx 会将node_modules 中的库 临时添加到环境变量# 命令行打包npx webpack ./src/main.js --mode=development","path":"2022/08/31/webpack学习笔记/","date":"08-31","excerpt":"","tags":[]},{"title":"django学习笔记","text":"框架自带的认证和权限12345678910111213141516171819202122232425262728293031323334353637383940414243from django.contrib.auth import login, authenticatefrom django.contrib.auth.models import User, Permissionfrom django.contrib.contenttypes.models import ContentTypefrom django.http import HttpResponse# Create your views here.from django.views import Viewfrom api10.models import Articleclass TestView(View): def get(self, request, *args, **kwargs): # 判断用户是否存在 user: User = authenticate(username=&quot;rox&quot;, password=&quot;abel&quot;) # 将该用户绑定到request完成登录 login(request, user) # 获取用户的所有权限 # print(user.get_all_permissions()) # 查询一个权限对象 从数据库中 # p1 = Permission.objects.filter(codename=&quot;can_view&quot;).first() # 给用户删除一个权限 # user.user_permissions.remove(p1) # 给用户添加一个权限 # user.user_permissions.add(p1) # print(user.get_all_permissions()) # 判断用户是否具有某种权限 权限字符串见下文 # app_name.codename # flag = user.has_perm(&quot;api10.can_view&quot;) # # print(flag) # 所谓的ContentType就是django提供的专门记录数据库中各种表信息的表 content_type = ContentType.objects.get_for_model(Article) permission = Permission.objects.create(codename=&#x27;can_block&#x27;, name=&#x27;user can block article&#x27;, content_type=content_type) return HttpResponse(&quot;abel&quot;) 框架自带的后台管理1234567from django.db import models# Create your models here.class Person(models.Model): username = models.CharField(max_length=64, verbose_name=&quot;姓名&quot;) 123456789101112131415161718# Register your models here.from django.contrib.admin import ModelAdmin, registerfrom api09.models import Person@register(Person)class PersonAdmin(ModelAdmin): list_display = [&quot;id&quot;, &quot;username&quot;, &quot;my_column&quot;] # hook 自定义列方法 # 方法名 与 list_display 里面指定的新增列名需要相同 def my_column(self, obj): # obj是当前行的对象 print(obj) # 返回值会作为 my_column 列的内容 return f&quot;abel &#123;obj.username&#125;&quot; 继承和扩展框架提供的User模型 使用框架提供的User模型好处是 可以使用框架提供的 认证和权限 免除重复造轮子 1234567891011121314151617181920from django.contrib.auth.models import AbstractUserfrom django.db import models# Create your models here.class MyUser(AbstractUser): &quot;&quot;&quot;自定义用户模型类&quot;&quot;&quot; # 额外增加 mobile 字段 长度11位 号码唯一 别名 mobile = models.CharField(max_length=11, unique=True, verbose_name=&#x27;手机号&#x27;) # 对当前表进行相关设置: # class Meta: # db_table = &#x27;tb_users&#x27; # 在 str 魔法方法中, 返回用户名称 def __str__(self): return self.username 1234# settings.py# 指定自定义的用户模型类 app_name.Model# 通知django使用该类进行认证和权限AUTH_USER_MODEL = &#x27;api08.MyUser&#x27; 一对一 一对多 多对多123456789101112131415161718192021222324252627282930from django.db import models# Create your models here.class Role(models.Model): role_name = models.CharField(max_length=64, verbose_name=&quot;角色名称&quot;) # 多对多 不需要 on_delete # 多对多 由于会产生中间表 中间表产生关联两头的外键 所以不会在本表中生成一个新的外键字段 users = models.ManyToManyField(to=&quot;UserInfo&quot;, related_name=&quot;user_roles&quot;, null=True, blank=True)class Group(models.Model): group_name = models.CharField(max_length=64, verbose_name=&quot;组名称&quot;)class UserInfo(models.Model): username = models.CharField(max_length=64, verbose_name=&quot;用户名&quot;) # ForeignKey 会在本表产生一个 group_id 的外键字段 # related_name=&quot;group_users&quot; 反向查询 其实就相当于在 Group表中 产生一个虚拟的 group_users字段 用户查询 group_obj.group_users.all() group = models.ForeignKey(to=Group, on_delete=models.CASCADE, related_name=&quot;group_users&quot;, null=True, blank=True)class UserToken(models.Model): token = models.CharField(max_length=64, verbose_name=&quot;token&quot;) user = models.OneToOneField(to=UserInfo, on_delete=models.CASCADE, related_name=&quot;user_token&quot;, null=True, blank=True) # OneToOneField 相当于 ForeignKey + unique约束 # user = models.ForeignKey(to=UserInfo, on_delete=models.CASCADE, related_name=&quot;user_token&quot;, null=True, blank=True, # unique=True) 123456789101112131415161718192021222324252627282930313233import osimport sysimport djangosys.path.append(os.getcwd())os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;drfreview.settings&quot;)django.setup()from api07.models import UserInfo, Role# u1 = UserInfo.objects.create(username=&quot;abel&quot;)# UserToken.objects.create(token=str(uuid4()), user=u1)# 正向查找# ut: UserToken = UserToken.objects.first()# print(ut.user)# 反向查找user: UserInfo = UserInfo.objects.first()print(user)# print(user.user_token.all())roles = user.user_roles.all()print(roles)r1: Role = Role.objects.filter(role_name=&quot;老师&quot;).first()print(r1.users.all())# r1.users.add(UserInfo.objects.create(username=&quot;rox&quot;)) 版本控制1re_path(r&#x27;^test2/(?P&lt;version&gt;[v1|v2|v3]+)/$&#x27;, Test2View.as_view(), name=&quot;test2&quot;), 12345678910from rest_framework.versioning import URLPathVersioningclass Test2View(APIView): versioning_class = URLPathVersioning def get(self, request, *args, **kwargs): # version = request.GET.get(&quot;version&quot;) print(request.version, request.versioning_scheme) data = &#123;&quot;code&quot;: 200&#125; return Response(data=data) 123456REST_FRAMEWORK = &#123; &#x27;VERSION_PARAM&#x27;: &#x27;version&#x27;, &#x27;DEFAULT_VERSION&#x27;: &#x27;v1&#x27;, &#x27;ALLOWED_VERSIONS&#x27;: [&#x27;v1&#x27;, &#x27;v2&#x27;], # &#x27;DEFAULT_VERSIONING_CLASS&#x27;: &#x27;rest_framework.versioning.URLPathVersioning&#x27;,&#125; 访问频率控制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Create your views here.import timefrom rest_framework.request import Requestfrom rest_framework.response import Responsefrom rest_framework.throttling import SimpleRateThrottlefrom rest_framework.views import APIViewclass MT2(SimpleRateThrottle): scope = &quot;scope&quot; THROTTLE_RATES = &#123; &quot;scope&quot;: &quot;3/m&quot; &#125; def get_cache_key(self, request, view): if request.META.get(&#x27;HTTP_X_FORWARDED_FOR&#x27;): ip = request.META.get(&quot;HTTP_X_FORWARDED_FOR&quot;) else: ip = request.META.get(&quot;REMOTE_ADDR&quot;) return ipVISIT_RECORD = &#123;&#125;# from rest_framework.throttling import BaseThrottleclass MyThrottle: &quot;&quot;&quot; 完全自定义的频率控制 有助于了解节流原理 &quot;&quot;&quot; def __init__(self): self.records = None self.duration = 10 def allow_request(self, request: Request, view): &quot;&quot;&quot; 重写该方法 进行计算是否被限流 :param request: :param view: :return: &quot;&quot;&quot; if request.META.get(&#x27;HTTP_X_FORWARDED_FOR&#x27;): ip = request.META.get(&quot;HTTP_X_FORWARDED_FOR&quot;) else: ip = request.META.get(&quot;REMOTE_ADDR&quot;) print(ip) now = time.time() if ip not in VISIT_RECORD: VISIT_RECORD.update(&#123;ip: [now]&#125;) return True else: records = VISIT_RECORD.get(ip) self.records = records while records and now - records[-1] &gt; self.duration: records.pop() if len(records) &lt; 3: records.insert(0, now) return True return False def wait(self): &quot;&quot;&quot; 重写该方法 用来提示节流还有多上时间结束 :return: &quot;&quot;&quot; return self.duration - (time.time() - self.records[-1])class TestView(APIView): throttle_classes = [MT2] def get(self, request, *args, **kwargs): data = &#123;&quot;code&quot;: 111&#125; return Response(data=data) ContentType django提供的多表关联1234567891011121314151617181920212223242526272829from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelationfrom django.contrib.contenttypes.models import ContentTypefrom django.db import models# Create your models here.class Course(models.Model): name = models.CharField(max_length=64, verbose_name=&quot;课程名称&quot;) # 不生成数据库字段 反向关联 course_obj.prices.all() 拿到所有的价格策略 prices = GenericRelation(&quot;PricePolicy&quot;)class DegreeCourse(models.Model): name = models.CharField(max_length=64, verbose_name=&quot;课程名称&quot;) # 不生成数据库字段 反向关联 prices = GenericRelation(&quot;PricePolicy&quot;)class PricePolicy(models.Model): price = models.FloatField(verbose_name=&quot;价格&quot;) content_type = models.ForeignKey(ContentType, verbose_name=&quot;关联表的表名&quot;, on_delete=models.CASCADE) object_id = models.IntegerField(verbose_name=&quot;关联表中的行ID&quot;) # 不生成字段 辅助content type 操作 # PricePolicy.objects.create(price=9.9, content_object=course_obj) content_object = GenericForeignKey(&quot;content_type&quot;, &quot;object_id&quot;) 123456789101112131415# Create your views here.from rest_framework.response import Responsefrom rest_framework.views import APIViewfrom api04.models import DegreeCourseclass TestView(APIView): def get(self, request, *args, **kwargs): obj = DegreeCourse.objects.filter(name=&quot;Java&quot;).first() # PricePolicy.objects.create(price=9.9, content_object=obj) # PricePolicy.objects.create(price=19.9, content_object=obj) # PricePolicy.objects.create(price=29.9, content_object=obj) print(obj.prices.all()) return Response(&#123;&quot;code&quot;: 1&#125;) 模型管理器 可以在模型管理器中自定义方法 可以在模型管理器中重写filter，做逻辑删除 123456789101112131415161718192021222324252627282930313233343536373839404142from django.db import models, connection# Create your models here.class MyBaseModelManager(models.Manager): def get_queryset(self): return super().get_queryset().filter(is_delete=False) @staticmethod def raw_sql_query(sql: str) -&gt; list[dict[str, str or int]]: &quot;&quot;&quot; 原生sql查询 :param sql: :return: &quot;&quot;&quot; with connection.cursor() as cursor: cursor.execute(sql) columns = [col[0] for col in cursor.description] datas = [dict(zip(columns, row)) for row in cursor.fetchall()] return datasclass MyModelManager(MyBaseModelManager): def get_id_gt_5(self): return self.model.mm.filter(id__gt=5) def get_id_lt_5(self): return self.model.mm.filter(id__lt=5)class Dog(models.Model): name = models.CharField(max_length=64, verbose_name=&quot;名字&quot;) is_delete = models.BooleanField(default=False, verbose_name=&quot;是否被删除&quot;) # 指定模型管理器 默认为 objects mm = MyModelManager() def __str__(self): return f&quot;&#123;self.name&#125; - &#123;self.is_delete&#125;&quot; 分页1234class MyPagination(PageNumberPagination): page_size = 3 page_size_query_param = &quot;size&quot; max_page_size = 10 12class T2View(APIView): pagination_class = MyPagination swagger接口文档1pip install drf_yasg 12345INSTALLED_APPS = [ ... &quot;rest_framework&quot;, &#x27;drf_yasg&#x27;, # swagger文档] 12345678910111213141516171819202122232425262728from django.contrib import adminfrom django.urls import path, includefrom drf_yasg import openapifrom drf_yasg.views import get_schema_viewschema_view = get_schema_view( openapi.Info( title=&quot;接口文档平台&quot;, # 必传 default_version=&#x27;v1&#x27;, # 必传 description=&quot;文档描述&quot;, terms_of_service=&#x27;&#x27;, contact=openapi.Contact(email=&quot;1093254791@qq.com&quot;), license=openapi.License(name=&quot;BSD LICENSE&quot;) ), public=True, # permission_classes=(permissions.) # 权限类)urlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;swagger/&#x27;, schema_view.with_ui(&#x27;swagger&#x27;, cache_timeout=0), name=&#x27;schema-swagger&#x27;), path(&#x27;redoc/&#x27;, schema_view.with_ui(&#x27;redoc&#x27;, cache_timeout=0), name=&#x27;schema-redoc&#x27;),] 1234567891011121314151617181920212223242526272829303132333435# Create your views here.from drf_yasg import openapifrom drf_yasg.utils import swagger_auto_schemafrom rest_framework.response import Responsefrom rest_framework.views import APIViewclass TestView(APIView): @swagger_auto_schema( # 接口描述，支持markdown语法 operation_description=&quot;&quot;&quot; 用户列表&quot;&quot;&quot;, # 接口参数 GET请求参数 manual_parameters=[ # 声明参数 openapi.Parameter( # 参数名称 &quot;name&quot;, # 参数形式 ?name=abel 的形式传参 openapi.IN_QUERY, # 参数描述 description=&quot;用户名称模糊搜索&quot;, # 参数类型 type=openapi.TYPE_STRING, # 是否必填 required=True, ), ], # 接口标题 operation_summary=&#x27;用户列表&#x27;, # 接口所属分组，会单独将接口拆出来放到 用户管理 分组中 tags=[&#x27;用户管理&#x27;] ) def get(self, request, *args, **kwargs): return Response(&#123;&quot;code&quot;: 2&#125;) 序列化（嵌套）及验证123456789101112from django.db import modelsclass Singer(models.Model): name = models.CharField(max_length=64, verbose_name=&quot;歌手名称&quot;)class Album(models.Model): name = models.CharField(max_length=64, verbose_name=&quot;专辑名称&quot;) singer = models.ForeignKey(to=Singer, related_name=&quot;albums&quot;, on_delete=models.CASCADE, verbose_name=&quot;所属歌手&quot;, null=True, blank=True) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from typing import OrderedDictfrom rest_framework import serializersfrom api12.models import Singer, Albumclass AlbumSer(serializers.ModelSerializer): class Meta: model = Album fields = &quot;__all__&quot;class SingerSer(serializers.ModelSerializer): # 体现反向关联 序列化器嵌套 # 此处的名称需要与 外键中指定的 related_name=&quot;albums&quot; 一致 albums = AlbumSer(many=True) class Meta: model = Singer fields = &quot;__all__&quot; def create(self, validated_data: dict): albums_data = validated_data.pop(&quot;albums&quot;) singer_obj: Singer = super().create(validated_data) print(&quot;++++&quot;, albums_data) album_objs = [Album.objects.create(**album) for album in albums_data] # [singer_obj.albums.add(Album.objects.create(**album)) for album in albums] # 新版django中，orm多对多外健不再用=等赋值,改为set方法 singer_obj.albums.set(album_objs) return singer_obj def validate_name(self, data): &quot;&quot;&quot; 验证单个数据 :param data: :return: &quot;&quot;&quot; print(&quot;验证&quot;, data) return data def validate(self, data: OrderedDict): &quot;&quot;&quot; 同时验证所有数据 :param data: :return: &quot;&quot;&quot; print(&quot;验证&quot;, data) return data 123456789101112131415161718192021222324# Create your views here.from rest_framework.request import Requestfrom rest_framework.response import Responsefrom rest_framework.views import APIViewfrom api12.MySerializer import SingerSerclass TestView(APIView): def post(self, request: Request, *args, **kwargs): print(request.data, type(request.data)) ser = SingerSer(data=request.data) print(ser.initial_data) if ser.is_valid(): print(&quot;----&quot;, ser.validated_data) ser.save() else: print(&quot;没通过校验&quot;) print(ser.errors) data = &#123; &quot;msg&quot;: &quot;success&quot; &#125; return Response(data=data) 事务方式一：装饰器 1234567891011121314from django.db import transaction class A(APIView): @transaction.atomic # 导入事务 def post(self, request, *args, **kwargs): try: save_id = transaction.savepoint() # 记录节点 pass # 操作内容 transaction.savepoint_commit(save_id) # 提交从上个节点到现在的改动到数据库 return HttpResponse(&quot;OK2&quot;) except Exception as e: transaction.savepoint_rollback(save_id) # 回到节点 return HttpResponse(&quot;错误&quot;) 方式二：with语法 12345678910111213from django.db import transaction class A(APIView): def post(self, request, *args, **kwargs): with transaction.atomic(): # 导入事务 try: save_id = transaction.savepoint() # 记录节点 pass # 操作内容 transaction.savepoint_commit(save_id) # 提交从上个节点到现在的改动到数据库 return HttpResponse(&quot;OK2&quot;) except Exception as e: transaction.savepoint_rollback(save_id) # 回到节点 return HttpResponse(&quot;错误&quot;)","path":"2022/08/24/django学习笔记/","date":"08-24","excerpt":"","tags":[]},{"title":"官网软件中心","text":"安装容器1234docker run -dit --name cpy -p 9000:9000 -v $&#123;HOME&#125;/share:/root/share python:3.8docker run -dit --name cng -p 9001:80 -v $&#123;HOME&#125;/nginx/www:/usr/share/nginx/html -v $&#123;HOME&#125;/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v $&#123;HOME&#125;/nginx/logs:/var/log/nginx nginx:1.15 加入同一网络1234docker network create -d bridge mynetdocker network connect mynet cpydocker network connect mynet cng uwsgi-socket.ini1234567891011121314151617181920212223242526272829303132[uwsgi]# 使用nginx反向代理时使用socket = 0.0.0.0:9000# 直接作为web服务器使用# http = 0.0.0.0:8888# 配置工程目录chdir = /root/share/softwarecenter# 配置项目的wsgi目录 注意是相对于工程目录wsgi-file = softwarecenter/wsgi.py# 指定静态文件路径# static-map = /static=/root/softwarecenter/statics# 服务器响应时间 服务器最大的计算时间 到时间就停止计算了 单位：秒harakiri = 3600# 前后端连接持续的时间 时间到了就断开连接 单位：秒socket-timeout=3600#http-timeout = 3600# 前后端请求数据的最大值 也就是请求体的最大值 单位：kbbuffer-size = 1024000# 最大请求连接数max-requests = 1000# 配置进程线程的信息processes = 4threads = 2enable-threads = Truemaster = Truepidfile = uwsgi.piddaemonize = uwsgi.log 进入cpy容器 安装依赖12pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/pip install uwsgi -i https://pypi.tuna.tsinghua.edu.cn/simple/ 收集项目静态文件123456# 配置收集静态文件的目录STATIC_ROOT = os.path.join(BASE_DIR, &quot;static_total&quot;)# 收集静态文件python manage.py collectstatic 进入cpy容器项目目录下 启动项目1uwsgi --ini uwsgi-socket.ini 将静态文件夹拷贝到cng的数据卷挂载中 static_total 拷贝到 ${HOME}&#x2F;nginx&#x2F;www nginx.conf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; client_max_body_size 800m; location / &#123; uwsgi_buffering off; include /etc/nginx/uwsgi_params; uwsgi_pass cpy:9000; uwsgi_connect_timeout 1800; uwsgi_read_timeout 1800; uwsgi_send_timeout 1800; &#125; location /static &#123; alias /usr/share/nginx/html/static_total; index index.html index.htm; &#125; &#125;&#125; 重启cng容器1docker restart cng 如果不能访问则需要开通云服务器的安全组策略端口如果停止了容器 再次启动容器 需要进入cpy容器 手动启一下项目 才能正常访问1uwsgi --ini uwsgi-socket.ini","path":"2022/07/26/官网软件中心/","date":"07-26","excerpt":"","tags":[]},{"title":"jenkins流水线持续集成和持续部署","text":"安装gitlab1234567docker pull gitlab-ce:latestdocker run -dit --name gitlab -p 9980:80 -v $&#123;HOME&#125;/config:/etc/gitlab -v $&#123;HOME&#125;/logs:/var/log/gitlab -v $&#123;HOME&#125;/data:/var/opt/gitlab gitlab-ce:latest# 如果想设置自启动docker update --restart=always 容器名称 安装jenkins123456789101112# 安装docker pull jenkins:ltsdocker run -d --name jenkins -u root -p 9982:8080 -p 50000:50000 --privileged=true -v $&#123;HOME&#125;/jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock jenkins:lts# 访问页面http://192.168.10.141:9982/# 查看初始密码docker logs jenkins# 参考资料https://blog.csdn.net/weixin_44249490/article/details/103687307 安装tomcat123456789101112131415161718192021222324252627282930313233343536373839# 安装tomcatdocker pull tomcat:8docker run -dit --name tomcat -p 9983:8080 -v $&#123;HOME&#125;/webapps:/usr/local/tomcat/webapps tomcat:8# 进入容器 复制tomcat manager到webapps目录下docker exec -it tomcat bashcp -r webapps.dist/* webapps# 修改 tomcat-users.xml 拷贝到数据卷中 然后到宿主机上改cp conf/tomcat-users.xml webapps# 在宿主机上修改 tomcat-users.xml&lt;role rolename=&quot;tomcat&quot;/&gt;&lt;role rolename=&quot;role1&quot;/&gt;&lt;role rolename=&quot;manager-script&quot;/&gt;&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;manager-status&quot;/&gt;&lt;role rolename=&quot;admin-gui&quot;/&gt;&lt;role rolename=&quot;admin-script&quot;/&gt;&lt;user username=&quot;abel&quot; password=&quot;abel&quot; roles=&quot;manager-gui,manager-script,tomcat,admin-gui,admin-script&quot;/&gt;# 进入容器 将tomcat-users.xml文件拷贝覆盖到conf目录下cp webapps/tomcat-users.xml conf/# 确认是否覆盖成功cat conf/tomcat-users.xml# 注释掉 context.xml 中的内容# webapps/manager/META-INF/context.xml 由于webapps是数据卷 可以在宿主机中直接修改注释掉 &lt;!-- &lt;Value className=.../&gt; --&gt;具体见下图# 重启容器docker restart tomcat# 访问tomcat页面http://192.168.10.141:9983/# 登录管理界面 上传war包进行测试http://192.168.10.141:9983/manager 持续集成持续部署脚本 流水线项目构建脚本 123456789101112131415node &#123; def mvnHome stage(&#x27;pull code&#x27;) &#123; echo &#x27;pull code&#x27; checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;*/master&#x27;]], extensions: [], userRemoteConfigs: [[credentialsId: &#x27;58198a85-ab8e-45d5-85ec-d39203edcd48&#x27;, url: &#x27;http://192.168.10.141:9980/cyj/tp06.git&#x27;]]]) &#125; stage(&#x27;build code&#x27;) &#123; echo &#x27;build code&#x27; sh &#x27;/root/apache-maven-3.8.6/bin/mvn clean package&#x27; &#125; stage(&#x27;develop code&#x27;) &#123; echo &#x27;develop code&#x27; deploy adapters: [tomcat8(credentialsId: &#x27;6ab973cd-1221-411d-b722-d9857ec74886&#x27;, path: &#x27;&#x27;, url: &#x27;http://192.168.10.141:9983/&#x27;)], contextPath: &#x27;/myproj&#x27;, war: &#x27;target/*.war&#x27; &#125;&#125; 拉取项目代码 构建war包 部署项目 安装deploy插件 关闭跨域限制 生成部署脚本 war文件所在位置 jenkins任务名&#x2F;target&#x2F;*.war","path":"2022/07/23/jenkins流水线持续集成和持续部署/","date":"07-23","excerpt":"","tags":[]},{"title":"SVN服务centos环境下搭建指南","text":"SVN服务搭建指南 适用范围：centos7系统 + svn服务端 + 自制svn用户密码修改服务（基于DjangoRestFramework开发） 1. 创建根目录存储svn仓库和svn配置1mkdir -p /svn/&#123;svndata,svnpasswd&#125; 2. 启动svn服务1234567891011121314# 启动svn服务**特别注意**：一定要启动所有仓库的根目录 而不能启动某个具体仓库 否则客户端checkout时会报url路径不存在# /svn/svndata 是作为所有仓库的根svnserve -d -r /svn/svndata 参数： -d：表示后台运行守护模式； -r：表示svn服务的根目录；检查svn服务是否启动ps -ef | grep svnserve检测svn端口3690是否已经监听：(svn默认启动3690端口)netstat -lntup | grep 3690# 如果提示端口已经占用可以先杀死端口,再初始化仓库pkill svnserve 3. 新建仓库1234# 创建cbct仓库目录mkdir -p /svn/svndata/cbct# 初始化仓库svnadmin create /svn/svndata/cbct 4. 修改配置文件便于统一管理123456# 拷贝 /svn/svndata/cbct/conf 的两个文件 authz passwd 到 /svn/svnpasswd 目录下 便于管理# 理由是 权限文件和用户文件默认是分散给各个仓库分散管理的 现在需要集中管理cp /svn/svndata/cbct/conf/authz /svn/svnpasswd/cp /svn/svndata/cbct/conf/passwd /svn/svnpasswd/# 修改 /svn/svndata/cbct/conf 下的 svnserve.conf 文件 指定集中管理的 authz 和 passwd 文件位置 123456# 需要修改的4个地方 且每个仓库的 svnserve.conf 都需要如此配置[general]anon-access = noneauth-access = writepassword-db = /svn/svnpasswd/passwdauthz-db = /svn/svnpasswd/authz 5. 配置用户、组、仓库的关系123# 创建用户vim /svn/svnpasswd/passwd# 按照 用户名 = 密码 的格式追加即可 如下图所示 1# 创建组 123456# 组&lt;--&gt;用户 的关系# 组名 = 用户名1,用户名2,用户名3[groups]group_cbct = chengyijun,xiangyang 1234567891011# 组&lt;--&gt;仓库 的关系# [仓库名:/] 表示对 该仓库下的根目录设置权限# 特别注意：引用组名前面需要带@符号# 注意仓库下的权限不仅可以绑定组 也可以直接绑定用户# r表示可读 w表示可写 rw可读写[cbct:/]@group_cbct = rwzhangbin = rw 重启svn服务 进行snv访问 123456789# 停止svn服务pkill svnserve# 开启svn服务 切记需要指定所有仓库的根 而不是具体仓库svnserve -d -r /svn/svndata# 客户端的svn填入地址为svn://39.103.186.2/cbct 6. 配置修改密码的web服务1234567# 为了防止修改密码的web服务没有操作 passwd 文件的权限 先进行提权sudo chmod 777 /svn/svnpasswd/passwd# 在修改密码的web服务中 指定 passwd 文件所在目录的位置 注意是目录位置 不是文件的全路径# 进入密码修改服务项目中 指定要操作的svn passwd文件位置vim /root/svntest/backend/backend/settings.py [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YdonSDyF-1630997778850)(C:\\Users\\abel\\Desktop\\SVN服务搭建.assets\\1630993118140.png)] 12345678910111213141516171819202122# 在djangorestframework项目中启动 修改密码的服务# 后台启动服务# nohup 表示不挂起# -u 参数的作用是取消python stdout的缓存 使其有结果就实时的网mylog文件中写# 2&gt;&amp;1 表示错误也重定向到 mylog 文件中# &amp; 表示后台执行nohup python3 -u manage.py runserver 0.0.0.0:8000 &gt; mylog 2&gt;&amp;1 &amp;# 查看服务运行情况 看mylog文件cat mylog或者 tail -f mylog# 如果需要停止服务可以进行如下操作# 查询进程号ps -ef|grep python3# 杀死进程kill 进程号# 打开浏览器访问就可以修改各个用户的密码# 旧的密码为创建用户时指定的密码浏览器访问 http://39.103.186.2:8000/","path":"2022/07/15/SVN服务centos环境下搭建指南/","date":"07-15","excerpt":"","tags":[]},{"title":"scrapy笔记","text":"scrapy笔记1. 添加随机UserAgent1234567from fake_useragent import UserAgentdef get_random_user_agent(path): res = UserAgent(path=path).random # print(res) return res 12345678910111213141516171819202122232425from fictiondemo.utils import get_random_user_agentclass RandomUserAgentMiddleware: @classmethod def from_crawler(cls, crawler): # This method is used by Scrapy to create your spiders. s = cls() crawler.signals.connect(s.spider_opened, signal=signals.spider_opened) return s def process_request(self, request, spider): random_user_agent = get_random_user_agent(path=&#x27;config/fake_useragent.json&#x27;) request.headers[&#x27;User-Agent&#x27;] = random_user_agent return None def process_response(self, request, response, spider): return response def process_exception(self, request, exception, spider): pass def spider_opened(self, spider): spider.logger.info(&#x27;Spider opened: %s&#x27; % spider.name) 12345DOWNLOADER_MIDDLEWARES = &#123; # None表示禁用 &#x27;fictiondemo.middlewares.FictiondemoDownloaderMiddleware&#x27;: None, &#x27;fictiondemo.middlewares.RandomUserAgentMiddleware&#x27;: 1,&#125; 2. crawlspider实例123456789101112131415161718192021222324252627282930313233343536373839404142import refrom scrapy.http import HtmlResponsefrom scrapy.linkextractors import LinkExtractorfrom scrapy.spiders import CrawlSpider, Ruleclass TxbcSpider(CrawlSpider): name = &#x27;txbc&#x27; # allowed_domains = [&#x27;tianxiabachang.zuopinj.com&#x27;] start_urls = [&#x27;http://tianxiabachang.zuopinj.com/&#x27;] rules = ( # \\d&#123;3,5&#125; 表示3~5（不含5）个数字 也就是一个前闭后开区间 # callback 指定是否需要回调函数来处理本次的响应 # follow=True 拿到本次提取到的链接 继续发请求 如果有callback就将请求得到的响应放到callback函数中 Rule(LinkExtractor(allow=r&#x27;/\\d&#123;3,5&#125;/$&#x27;), follow=True), Rule(LinkExtractor(allow=r&#x27;/\\d+\\.html$&#x27;), callback=&#x27;parse_item&#x27;, follow=True), ) def parse_item(self, response: HtmlResponse): item = &#123;&#125; # http://tianxiabachang.zuopinj.com/11350/299356.html url = response.url res = re.findall(r&#x27;http://tianxiabachang.zuopinj.com/(.*?)/(.*?).html&#x27;, url)[0] book_id = res[0] chapter_id = res[1] title = response.xpath(&#x27;//h1/text()&#x27;).get(None) ps = response.xpath(&#x27;//*[@id=&quot;htmlContent&quot;]//p&#x27;) for index, p in enumerate(ps, start=1): content = p.xpath(&#x27;.//text()&#x27;).get(None) if any([content is None, content == &#x27;\\xa0\\xa0&#x27;]): continue # print(book_id, chapter_id, index, title, res) item.setdefault(&#x27;book_id&#x27;, book_id) item.setdefault(&#x27;chapter_id&#x27;, chapter_id) item.setdefault(&#x27;index&#x27;, index) item.setdefault(&#x27;title&#x27;, title) item.setdefault(&#x27;content&#x27;, content) return item","path":"2022/07/15/scrapy笔记/","date":"07-15","excerpt":"","tags":[]},{"title":"jenkins搭建","text":"Jenkins配置教程centos7 关闭selinux 1vi /etc/selinux/config 将SELINUX&#x3D;enforcing改为SELINUX&#x3D;disabled 设置后需要重启才能生效 关闭防火墙并禁止自动启动 123systemctl stop firewalldsystemctl disable firewalldsystemctl status firewalld 换源 配置静态ip 1cd /etc/sysconfig/network-scripts/ 123456789101112TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticIPADDR=192.168.130.130NETMASK=255.255.255.0GATEWAY=192.168.130.1DEFROUTE=yesIPV4_FAILURE_FATAL=noNAME=ens34DEVICE=ens34ONBOOT=yes gitlab服务器1234567891011121314151617181920# 安装依赖yum install -y curl policycoreutils-python openssh-server openssh-clients postfix# 配置sshdsystemctl enable sshd &amp;&amp; systemctl start sshd# 配置邮件服务systemctl enable postfix &amp;&amp; systemctl start postfix# 下载gitlabwget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6/gitlab-ce-12.4.2-ce.0.el6.x86_64.rpm# 安装gitlabrpm -ivh gitlab-ce-12.4.2-ce.0.el6.x86_64.rpm# 配置gitlabvi /etc/gitlab/gitlab.rbexternal_url &#x27;http://192.168.130.131:82&#x27;nginx[&#x27;listen_port&#x27;] = 82# 让配置生效gitlab-ctl reconfiguregitlab-ctl restart# gitlab 首次访问会让修改密码(密码要求8位)root/00000000 jenkins服务器安装jdk 1yum install java-1.8.0-openjdk* -y 123456789101112132.安装[root@ticent admin]# yum install java-1.8.0-openjdk.x86_643.添加环境变量 vi /etc/profileJAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.282.b08-1.el7_9.x86_64JRE_HOME=$JAVA_HOME/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH4.验证有效性[root@ticent admin]# java -versionopenjdk version &quot;1.8.0_131&quot;OpenJDK Runtime Environment (build 1.8.0_131-b12)OpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode) 下载jenkins wget … 上传jenkins yum install lrzsz -y rz … 安装jenkins rpm -ivh … 配置jenkis vim &#x2F;etc&#x2F;sysconfig&#x2F;jenkins JENKINS_USER&#x3D;”root” JENKINS_PORT&#x3D;”8888” 启动jenkins systemctl start jenkins 访问jenkins http://192.168.130.132:8888/ 首次访问会要求填写初始密码 cat &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;secrets&#x2F;initialAdminPassword 创建用户如下： abel&#x2F;000000 测试环境服务器","path":"2022/07/15/jenkins搭建/","date":"07-15","excerpt":"","tags":[]},{"title":"drf分页实例","text":"12345678910111213141516171819202122232425262728293031323334353637from rest_framework import serializersclass StudentSerializers(serializers.ModelSerializer): class Meta: model = Students # 设置关联模型 model就是关联模型 fields = &#x27;__all__&#x27; # fields设置字段 __all__表示所有字段 # fields = [&#x27;content&#x27;, &#x27;location&#x27;] # 排除的字段 直接丢弃 不验证 不入库 # exclude = [&#x27;topic&#x27;, &#x27;user&#x27;] # exclude = []class MyPageNumberPagination(PageNumberPagination): # 每页默认获取的条数 size=10 page_size = 10 # 指定当前获取条数 page_size_query_param = &#x27;size&#x27; # 指定当前页数 page_query_param = &quot;page&quot;class StudentView(APIView): def get(self, request: Request, *args, **kwargs): # 获取所有 students = Students.objects.all() # 创建分页对象 pg = MyPageNumberPagination() # 获取分页的数据 page_roles = pg.paginate_queryset(queryset=students, request=request, view=self) # 对数据进行序列化 ser = StudentSerializers(instance=page_roles, many=True) return Response(ser.data)","path":"2022/07/15/drf分页实例/","date":"07-15","excerpt":"","tags":[]},{"title":"drf的认证-权限节流-版本-控制实例","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129# Create your views here.import timefrom rest_framework import exceptionsfrom rest_framework.authentication import BaseAuthenticationfrom rest_framework.permissions import BasePermissionfrom rest_framework.request import Requestfrom rest_framework.response import Responsefrom rest_framework.throttling import BaseThrottle, SimpleRateThrottlefrom rest_framework.versioning import BaseVersioningfrom rest_framework.views import APIViewvisit_records = &#123;&#125;class MyBaseVersioning(BaseVersioning): &quot;&quot;&quot; 版本控制 &quot;&quot;&quot; versions = [&#x27;v1&#x27;, &#x27;v2&#x27;] def determine_version(self, request: Request, *args, **kwargs): version = request.query_params.get(&#x27;version&#x27;) if version not in self.versions: raise exceptions.APIException(detail=&#123;&#x27;msg&#x27;: &#x27;版本不正确&#x27;&#125;) return versionclass MyScopedRateThrottle(SimpleRateThrottle): &quot;&quot;&quot; 节流控制（继承自drf框架实现） &quot;&quot;&quot; scope = &#x27;visit&#x27; THROTTLE_RATES = &#123; &#x27;visit&#x27;: &#x27;6/m&#x27;, # 每分钟访问6次 &#125; def get_cache_key(self, request, view): return request.META.get(&#x27;REMOTE_ADDR&#x27;)class MyThrottle(BaseThrottle): &quot;&quot;&quot; 节流控制（自定义） &quot;&quot;&quot; def allow_request(self, request: Request, view): # 拿到访问的IP ip = request.META.get(&#x27;REMOTE_ADDR&#x27;) # 访问记录 # &#123;ip: [timestamp1, timestamp2]&#125; now = time.time() if ip not in visit_records.keys(): # 如果是第一次访问就将ip加入到访问记录中 visit_records.setdefault(ip, [now]) # 获取该ip的访问记录 history = visit_records.get(ip) # 如果记录中最先一次的访问时间 超出频率 则移除 if now - history[-1] &gt; 10.0: # 移除过期的访问记录 history.pop() # 判断是否可以访问 if len(history) &lt; 5: # 更新该ip的访问时间记录 visit_records.get(ip).insert(0, now) return True return Falseclass MyPermission(BasePermission): &quot;&quot;&quot; 权限控制 &quot;&quot;&quot; def has_permission(self, request, view): # 抛出异常或者返回False 表示没有权限 # raise exceptions.PermissionDenied(detail=&#123;&#x27;msg&#x27;: &#x27;没有权限哦&#x27;&#125;) # return False # 返回True 表示有权限 return Trueclass MyAuthentication(BaseAuthentication): &quot;&quot;&quot; 认证控制 &quot;&quot;&quot; def authenticate(self, request: Request): token = request.query_params.dict().get(&#x27;token&#x27;) if not token: # 第一种结果： 抛出异常，认证失败，并终止向后认证 raise exceptions.AuthenticationFailed(detail=&#123;&#x27;msg&#x27;: &#x27;认证失败&#x27;&#125;) if token == &#x27;123&#x27;: # 第二种结果： 返回tuple，认证成功，并终止向后认证 return &#x27;abel&#x27;, token # 第三种结果： 返回None，不进行任何认证，继续向后认证 return Noneclass TestView(APIView): # 配置认证控制类 authentication_classes = [MyAuthentication] # 配置权限控制类 permission_classes = [MyPermission] # 配置节流控制类 throttle_classes = [MyScopedRateThrottle] # 配置版本控制类 注意此处是单个的类 而不是列表 versioning_class = MyBaseVersioning def get(self, requests, *args, **kwargs): print(self) print(&#x27;get&#x27;) print(requests) data = dict(list(zip(&#x27;abcd&#x27;, range(4)))) return Response(data) def post(self, requests, *args, **kwargs): print(self) print(&#x27;post&#x27;) print(requests) print(requests.FILES) file = requests.FILES.dict().get(&#x27;file&#x27;) for chuck in file.chunks(): with open(&#x27;aaa.png&#x27;, &#x27;wb&#x27;) as f: f.write(chuck) data = dict(list(zip(&#x27;efgh&#x27;, range(4)))) return Response(data)","path":"2022/07/15/drf的认证-权限节流-版本-控制实例/","date":"07-15","excerpt":"","tags":[]},{"title":"自封装的python38-dockerfile","text":"自己封装的py38环境 Dockfile编写 添加启动脚本 1sudo vi /var/lib/boot2docker/bootlocal.sh 1234567# 自动挂在共享文件夹mkdir -p ~/vmshare/sudo mount -t vboxsf vmshare ~/vmshare/#更改时区、时间（/mnt/sda1/localtime是从别的服务器cp过阿里的/usr/share/zoneinfo/Asia/Shanghai）cp -f /mnt/sda1/localtime /etc/localtime &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone;#Docker 中国官方镜像加速echo &quot;&#123;\\&quot;registry-mirrors\\&quot;: [\\&quot;https://registry.docker-cn.com\\&quot;]&#125;&quot; &gt; /etc/docker/daemon.json; 1234567891011121314FROM wynemo/python38RUN cd /root \\ &amp;&amp; mkdir .pip \\ &amp;&amp; mkdir .venvs \\ # 安装virtualenvwrapper &amp;&amp; pip install virtualenvwrapper \\ # 修改pip源 &amp;&amp; echo &quot;[global] \\n index-url = http://mirrors.aliyun.com/pypi/simple/ \\n [install] \\n trusted-host = mirrors.aliyun.com \\n&quot; &gt; .pip/pip.conf \\ # 修复virtualenv &amp;&amp; pip install --upgrade virtualenv==16.7.9 \\ # 配置.bashrc文件 &amp;&amp; echo &quot;WORKON_HOME=~/.venvs \\n VIRTUALENVWRAPPER_VIRTUALENV_ARGS=&#x27;--no-site-packages&#x27; \\n VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python \\n export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenv \\n source /usr/local/bin/virtualenvwrapper.sh \\n&quot; &gt;&gt; .bashrc \\ # 使配置文件生效 &amp;&amp; /bin/bash -c &quot;source .bashrc&quot; 根据Dockfile生成镜像 1docker build -t mypy38env:v5 . 删除所有已经关闭的容器 1docker rm `docker ps -a|grep Exited|awk &#x27;&#123;print $1&#125;&#x27;`","path":"2022/07/15/自封装的python38-dockerfile/","date":"07-15","excerpt":"","tags":[]},{"title":"vbox共享文件夹设置","text":"vbox共享文件夹设置 1sudo mount -t vboxsf vmshare ~/vmshare/ 注意 vboxsf 是vbox文件格式 vmshare是前面设置的共享文件夹的名称","path":"2022/07/15/vbox共享文件夹设置/","date":"07-15","excerpt":"","tags":[]},{"title":"docker常用命令","text":"docker常用命令镜像加速 对于使用 systemd 的系统，请在 &#x2F;etc&#x2F;docker&#x2F;daemon.json 中写入如下内容（如果文件不存在请新建该文件）： 1&#123;&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]&#125; 之后重新启动服务： $ sudo systemctl daemon-reload$ sudo systemctl restart docker 启动docker服务 systemctl start docker 查找镜像 docker search 镜像名 下载镜像 docker pull 镜像名 查询已下载的镜像 docker images 删除镜像 docker rmi 镜像id 启动容器 docker run –name centos-test -dit centos:latest 停止容器 docker start 容器名&#x2F;容器id 删除容器 docker rm 容器名&#x2F;容器id 查看容器 docker ps -a 进入容器 docker exec -it 容器名 &#x2F;bin&#x2F;bash","path":"2022/07/15/docker常用命令/","date":"07-15","excerpt":"","tags":[]},{"title":"python+appium测试移动端app流程","text":"1. 下载android sdk 2. 配置 android sdk 配置 ANDROID_HOME和Path 12345678910ANDROID_HOMED:\\Program Files (x86)\\Android\\android-sdkPath%ANDROID_HOME%%ANDROID_HOME%\\tools%ANDROID_HOME%\\platform-tools%ANDROID_HOME%\\build-tools 配置Path ​ 3. 安装模拟器 自行下载安装android模拟器即可 （此处安装的是 夜神模拟器） 注意 为了版本一致性 防止出错 可以将android sdk根目录\\platform-tools\\adb.exe 复制一份出来并改名nox_adb.exe 覆盖到夜神模拟器根目录 4. 通过adb连接模拟器 通过adb查询一下连接的设备列表 手动连接一下模拟器 注意 不同的模拟器 端口可能不一样 夜神模拟器是62001 其他的可以查询 5. 配置appium 四项基本配置 123456&#123; &quot;deviceName&quot;: &quot;127.0.0.1:62001&quot;, &quot;platformName&quot;: &quot;Android&quot;, &quot;appPackage&quot;: &quot;com.bignox.google.installer&quot;, &quot;appActivity&quot;: &quot;.MainActivity&quot;&#125; 上述第3项 第4项 可以通过如下指令查询到 前提是在模拟器上将待测软件打开到启动界面 以下命令可以获取当前启动状态的app的 包名和activity名 12adb shelldumpsys activity | grep &quot;mFoc&quot; 配置好四项基本配置之后，可以开启会话 appium就得到了模拟器的图像 6. 安装 appium-python-client 此模块用来安装appium 像selenium一样通过python来操作 1pip install appium-python-client 7. 通过元素id进行定位 可以借助android sdk目录下的 8. python代码示例12345678910111213141516171819202122232425262728293031323334# -*- coding:utf-8 -*-&quot;&quot;&quot;@author: chengyijun@contact: cyjmmy@foxmail.com@file: test1.py@time: 2020/12/7 15:06@desc:&quot;&quot;&quot;def main(): from appium import webdriver caps = &#123;&#125; # 平台名称 Android or Ios caps[&quot;platformName&quot;] = &quot;Android&quot; # 包名 caps[&quot;appPackage&quot;] = &quot;com.bignox.google.installer&quot; # activity名 caps[&quot;appActivity&quot;] = &quot;.MainActivity&quot; # 键盘输入设置 （不是必须的） caps[&quot;resetKeyboard&quot;] = True caps[&quot;unicodeKeyboard&quot;] = True # 连接appium服务器 路径&#x27;/wd/hub&#x27;是固定的 driver = webdriver.Remote(&quot;http://localhost:4723/wd/hub&quot;, caps) # 通过元素id定位 并操作点击 driver.find_element_by_id(&#x27;com.bignox.google.installer:id/install&#x27;).click() # 退出driver driver.quit()if __name__ == &#x27;__main__&#x27;: main()","path":"2022/07/15/python-appium测试移动端app流程/","date":"07-15","excerpt":"","tags":[]},{"title":"stacked组件和tab组件的使用","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# -*- coding: utf-8 -*-# @Author : chengyijun# @Time : 2020/9/17 15:21# @File : stacked_demo.py# @desc : pyqt5 stacked组件和tab组件的使用import sysfrom PyQt5.QtCore import pyqtSlotfrom PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QLabelfrom login import Ui_Form as Ui_Loginfrom tab import Ui_Form as Ui_Tabfrom stacked import Ui_MainWindowclass Tab(Ui_Tab, QWidget): def __init__(self, parent=None) -&gt; None: super().__init__(parent=parent) self.setupUi(self) q_label = QLabel(text=&quot;我是tab的内容&quot;) self.tabWidget.addTab(q_label, &quot;tab3&quot;)class Login(Ui_Login, QWidget): def __init__(self, parent=None) -&gt; None: super().__init__(parent=parent) self.setupUi(self)class Demo(Ui_MainWindow, QMainWindow): def __init__(self) -&gt; None: super().__init__() self.setupUi(self) @pyqtSlot() def on_pushButton_clicked(self): # self.stackedWidget.setCurrentIndex(0) login = Login() self.stackedWidget.insertWidget(0, login) self.stackedWidget.setCurrentIndex(0) @pyqtSlot() def on_pushButton_2_clicked(self): tab = Tab() self.stackedWidget.insertWidget(1, tab) self.stackedWidget.setCurrentIndex(1) @pyqtSlot() def on_pushButton_3_clicked(self): print(&#x27;gwc&#x27;)def main(): app = QApplication(sys.argv) demo = Demo() demo.show() sys.exit(app.exec_())if __name__ == &#x27;__main__&#x27;: main()","path":"2022/07/15/stacked组件和tab组件的使用/","date":"07-15","excerpt":"","tags":[]},{"title":"使用drf框架编写api","text":"安装djangorestframework1pip install djangorestframework 修改常用配置12345678910111213141516171819202122232425DEBUG = TrueALLOWED_HOSTS = [&#x27;*&#x27;]DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;api&#x27;, &#x27;USER&#x27;: &#x27;abel&#x27;, &#x27;PASSWORD&#x27;: &#x27;abel&#x27;, &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;, &#x27;POST&#x27;: 3306, &#125;&#125;INSTALLED_APPS = [ ... &#x27;rest_framework&#x27;, &#x27;你的app名称&#x27;,]LANGUAGE_CODE = &#x27;zh-hans&#x27;TIME_ZONE = &#x27;Asia/Shanghai&#x27;USE_TZ = False 项目的同名目录下的 init.py 1234import pymysqlpymysql.install_as_MySQLdb() url 路由分发12345from django.urls import path, includeurlpatterns = [ path(&#x27;api/&#x27;, include(&quot;api.urls&quot;, namespace=&#x27;api&#x27;))] 12345678910111213141516from django.urls import path, re_pathfrom api import viewsapp_name = &#x27;api&#x27;urlpatterns = [ path(&#x27;login/&#x27;, views.LoginView.as_view(), name=&#x27;login&#x27;), path(&#x27;code/&#x27;, views.CodeView.as_view(), name=&#x27;code&#x27;), path(&#x27;tempauth/&#x27;, views.TempAuthView.as_view(), name=&#x27;tempauth&#x27;), # APIView path(&#x27;articles/&#x27;, views.ArticleView.as_view(), name=&#x27;articles&#x27;), re_path(r&#x27;article/(?P&lt;id&gt;\\d+)/$&#x27;, views.ArticleDetailView.as_view(), name=&#x27;article-detail&#x27;), # 等价于上面的写法 建议使用上面一种 便于理解 # path(&#x27;article/&lt;id&gt;/&#x27;, views.ArticleDetailView.as_view(), name=&#x27;article-detail&#x27;),] view 编写 为了方便复用，尽量使用 ListAPIView, CreateAPIView, （此二者可以合并为 ListCreateAPIView） RetrieveAPIView, UpdateAPIView, DestroyAPIView 按照上面编写的路由规则 访问url形式为： &#96;&#96;&#96;http://127.0.0.1:8000/api/articles/http://127.0.0.1:8000/api/article/78/ 12345678910111213141516171819202122232425262728```pythonclass ArticleView(CreateAPIView, ListAPIView): # 查询结果集 queryset = Articles.objects.all() # 序列化器类 # serializer_class = ArticleSerializer # 自定义分页器 pagination_class = MyPageNumberPagination # 自定义queryset结果集 filter_backends = [ArticleFilter] def get_serializer_class(self): # 根据不同请求 加载不同的序列化器 if self.request.method == &#x27;POST&#x27;: return ArticleSerializer elif self.request.method == &#x27;GET&#x27;: return ArticleSerializerForList # 钩子 重写该方法可以在 序列化完成 数据入库之前的时机 插入其他字段值 def perform_create(self, serializer): print(serializer.initial_data) userinfo_id = serializer.initial_data.get(&#x27;user&#x27;) topic_id = serializer.initial_data.get(&#x27;topic&#x27;) # serializer.save() 方法的内部 又调用了 序列化器中的 create()方法 article_obj = serializer.save(topic_id=topic_id, user_id=userinfo_id) return article_obj 1234567class ArticleDetailView(RetrieveAPIView, UpdateAPIView, DestroyAPIView): # 查询结果集 queryset = Articles.objects.all() # 序列化器类 serializer_class = ArticleSerializerForList # django 默认的主键形参为pk 如果改用其他 应通过 lookup_field 显试指定出来 lookup_field = &#x27;id&#x27; 分页器 12345678910111213141516171819202122232425262728from rest_framework.pagination import LimitOffsetPaginationclass MyPageNumberPagination(LimitOffsetPagination): # 默认数据量 default_limit = 10 # 最大数据量 max_limit = 50 # 数据量 limit_query_param = &#x27;limit&#x27; # 起始偏移位置 offset_query_param = &#x27;offset&#x27; def get_paginated_response(self, data): &quot;&quot;&quot; overwrite 不要父类给的数据格式 :param data: :return: &quot;&quot;&quot; return Response(data) def get_offset(self, request): &quot;&quot;&quot; overwrite 让起始偏移量 始终为0 :param request: :return: &quot;&quot;&quot; return 0 结果集过滤器 1234567891011121314class ArticleFilter(BaseFilterBackend): def filter_queryset(self, request, queryset, view): min_id = request.query_params.get(&#x27;min_id&#x27;) max_id = request.query_params.get(&#x27;max_id&#x27;) if min_id: # 处理上滑 翻页 queryset = queryset.filter(id__lt=min_id).order_by(&#x27;-id&#x27;) elif max_id: # 处理 下拉刷新 queryset = queryset.filter(id__gt=max_id).order_by(&#x27;-id&#x27;) else: queryset = queryset.order_by(&#x27;-id&#x27;) return queryset 序列化器 12345class ArticleImageSerializer(serializers.ModelSerializer): class Meta: model = ArticleImages # 设置关联模型 model就是关联模型 # fields = &#x27;__all__&#x27; # fields设置字段 __all__表示所有字段 exclude = [] 1234567891011121314151617181920212223242526272829class ArticleSerializer(serializers.ModelSerializer): # 此处为序列化器的嵌套 应用于关联表 images = ArticleImageSerializer(many=True) class Meta: model = Articles # 设置关联模型 model就是关联模型 # fields = &#x27;__all__&#x27; # fields设置字段 __all__表示所有字段 # fields = [&#x27;content&#x27;, &#x27;location&#x27;] # 排除的字段 直接丢弃 不验证 不入库 exclude = [&#x27;topic&#x27;, &#x27;user&#x27;] # exclude = [] # view中数据保存方法 save()执行之前 会调用该方法 通常应用在 序列化器嵌套情况下 一并将嵌套表的字段 入库 def create(self, validated_data): images = validated_data.pop(&#x27;images&#x27;) article_obj = Articles.objects.create(**validated_data) images_obj = [ArticleImages.objects.create(**image, article=article_obj) for image in images] article_obj.images = images_obj return article_obj # 验证字段 钩子 # def validate_content(self, value): # &quot;&quot;&quot; 验证是否还正在拍卖&quot;&quot;&quot; # print(&#x27;正在验证&#x27;, value) # # item_id = self.initial_data.get(&#x27;item&#x27;) # # exists = models.AuctionItem.objects.filter(id=item_id, status=3).exists() # # if not exists: # # raise exceptions.ValidationError(&#x27;拍卖商品不存在或已成交&#x27;) # return value 123456789101112131415161718192021222324252627class ArticleSerializerForList(serializers.ModelSerializer): class Meta: model = Articles exclude = [] # 定义模型中没有的数据字段 topic = serializers.SerializerMethodField(label=&#x27;所属话题&#x27;, default=&#x27;默认话题内容...&#x27;, read_only=True) user = serializers.SerializerMethodField(label=&#x27;所属用户手机号&#x27;, default=&#x27;13333333333&#x27;, read_only=True) images = serializers.SerializerMethodField(label=&#x27;文章包含的图片&#x27;, default=&#x27;&#x27;, read_only=True) # 钩子方法 固定格式 get_xx(self,value) xx表示上面对应的自定义字段 value表示当前的model对象 def get_images(self, value): images = ArticleImages.objects.filter(article_id=value.id).all() datas = [] for image in images: datas.append(&#123; &#x27;cos_path&#x27;: image.cos_path, &#x27;key&#x27;: image.key &#125;) return datas def get_topic(self, value): topic = value.topic return model_to_dict(instance=topic) def get_user(self, value): user = value.user return model_to_dict(instance=user) model中外键和多对多关系的用法 related_name 用作反向关联取得别名 如果表A中有两个外键字段 指向表B中的id 表B方向关联查找数据的时候就不知道应该反向关联谁了 related_name 显示指定别名可以防止此类情况关联自己 可以使用self 1234567891011class Comments(models.Model): content = models.CharField(verbose_name=&#x27;评论内容&#x27;, max_length=255) depth = models.IntegerField(verbose_name=&#x27;评论级别&#x27;) # 外键 article = models.ForeignKey(verbose_name=&#x27;所属文章&#x27;, to=&#x27;Articles&#x27;, on_delete=models.CASCADE, null=True, blank=True) user = models.ForeignKey(verbose_name=&#x27;所属用户&#x27;, to=&#x27;Users&#x27;, on_delete=models.CASCADE, null=True, blank=True) root = models.ForeignKey(verbose_name=&#x27;所属根评论&#x27;, to=&#x27;self&#x27;, related_name=&#x27;roots&#x27;, null=True, blank=True, on_delete=models.CASCADE) reply = models.ForeignKey(verbose_name=&#x27;上级评论&#x27;, to=&#x27;self&#x27;, related_name=&#x27;replys&#x27;, null=True, blank=True, on_delete=models.CASCADE) 123456789101112class Articles(models.Model): content = models.CharField(verbose_name=&#x27;文章内容&#x27;, max_length=255) location = models.CharField(verbose_name=&#x27;地理位置&#x27;, max_length=255) view_count = models.PositiveIntegerField(verbose_name=&#x27;浏览数&#x27;, default=0) like_count = models.PositiveIntegerField(verbose_name=&#x27;点赞数&#x27;, default=0) comment_count = models.PositiveIntegerField(verbose_name=&#x27;评论数&#x27;, default=0) # 外键 topic = models.ForeignKey(verbose_name=&#x27;所属话题&#x27;, to=&#x27;Topics&#x27;, on_delete=models.CASCADE, null=True, blank=True) user = models.ForeignKey(verbose_name=&#x27;所属用户&#x27;, to=&#x27;Users&#x27;, on_delete=models.CASCADE, null=True, blank=True) # 浏览记录 多对多 viwers = models.ManyToManyField(&#x27;Users&#x27;, related_name=&#x27;views&#x27;) 上面的多对多关系 起始就是建立了中间表 中间表使用两个外键关联两张表 构成多对多关系 与手动创建中间表效果一样 1234class ViewRecords(models.Model): # 外键 user = models.ForeignKey(verbose_name=&#x27;所属用户&#x27;, to=&#x27;Users&#x27;, on_delete=models.CASCADE, null=True, blank=True) article = models.ForeignKey(verbose_name=&#x27;所属文章&#x27;, to=&#x27;Articles&#x27;, on_delete=models.CASCADE, null=True, blank=True) 跨表取值 A表含有主键指向B表 现有A表的模型对象a 可以直接通过 __a.主键名__获取B表模型对象从而得到B表的数据 （主动查询） 反之，现有B表的模型对象b，想通过b取到A表的值，可以通过 b.a表小写表名_set 来得到A表中的数据 _set 为固定格式写法 数据库填充数据脚本 原理 就是在外部通过加载django环境 让脚本中可以利用django的model快速操作数据库 1234567891011121314151617181920212223242526272829303132333435363738394041424344import osimport randomimport sysimport uuidsys.path.append(os.getcwd())os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;miniprogramapi.settings&quot;)import djangodjango.setup()from api.models import Topics, Articles, Users, ArticleImages# 新增用户for _ in range(20): r = random.randint(111111111, 999999999) Users.objects.create( phone=f&#x27;13&#123;r&#125;&#x27;, token=uuid.uuid4(), nickname=f&#x27;哨兵&#123;r&#125;号&#x27;, avatar=&#x27;http://himg.bdimg.com/sys/portrait/item/c9eee4b89ce69da5e4b89ce5be80e79a84e78caaa629.jpg&#x27; )# 新增话题for _ in range(20): r = random.randint(1, 200) Topics.objects.create( content=f&quot;我是话题&#123;r&#125;&quot;, hot=r )# 新增文章for _ in range(20): r = random.randint(1, 200) Articles.objects.create( content=f&quot;文章内容&#123;r&#125;&quot;, location=f&quot;明珠路&#123;r&#125;&quot;, view_count=1, like_count=1, comment_count=1, topic=Topics.objects.get(id=random.choice([topic.id for topic in Topics.objects.all()])), user=Users.objects.get(id=random.choice([user.id for user in Users.objects.all()])) ) 序列化器中数据的校验 方法一 指定数据行验证类 利用 call()方法进行校验 12345678910111213141516171819class LoginSerializer(serializers.Serializer): phone = serializers.CharField(label=&#x27;手机号&#x27;, validators=[PasswordValidator()]) class PasswordValidator(object): def __init__(self): pass def __call__(self, value, *args, **kwargs): if len(value) != 11: raise serializers.ValidationError(&#x27;手机号码长度不正确&#x27;) if not re.match(r&#x27;^\\d+$&#x27;, value): raise serializers.ValidationError(&#x27;手机号必须为数字&#x27;) def set_context(self, serializer_field): # print(serializer_field) pass 方法二 指定自定义验证函数 1234567class LoginSerializer(serializers.Serializer): phone = serializers.CharField(label=&#x27;手机号&#x27;, validators=[foo])# 自定义的验证函数 value表示被验证字段def foo(value): pass 方法三 使用钩子 12345678910class LoginSerializer(serializers.Serializer): phone = serializers.CharField(label=&#x27;手机号&#x27;) # 以 validate_xxx 形式开头的方法是验证钩子 会自动调用进行字段验证 def validate_phone(self, value): print(value + &#x27;``````````&#x27;) raise serializers.ValidationError(&#x27;aaaa&#x27;) return value 登录认证123456789REST_FRAMEWORK = &#123; # 未认证情况下 默认用户和令牌为None &#x27;UNAUTHENTICATED_TOKEN&#x27;: None, &#x27;UNAUTHENTICATED_USER&#x27;: None, # 可以通过全局指定的方式 指定登录认证的中间件位置 &#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;: [&#x27;api.utils.LoginAuthentication&#x27;]&#125; 1234567891011121314151617181920212223242526272829303132from rest_framework.authentication import BaseAuthenticationfrom api.models import Usersclass MyGeneralAuthentication(BaseAuthentication): def authenticate(self, request): &quot;&quot;&quot; :param request: :return: None -表示本认证器不做任何处理直接交给下一个认证器 认证成功会返回一个元组 (user,token) 表示认证成功 并分贝绑定在 request.user request.auth 属性上 &quot;&quot;&quot; # 获取token # 注意： 特别值得注意的是 前端 header = &#123; # &#x27;authentication&#x27;: 578fff92-e481-4223-a49a-427cdadfd915 # &#125; # drf框架中接收的时候 需要 加 HTTP_ 前缀 并将key全大写 token = request.META.get(&#x27;HTTP_AUTHENTICATION&#x27;, None) # 如果token没有带过来 if not token: return None # 如果token是错误的 user = Users.objects.filter(token=token).first() if not user: return None # 通过认证 会返回一个元组（登录用户对象，登录用户token） 并将其作为request属性绑定上 使用的时候可以通过 # request.user request.auth 拿到 # print(user, token) return user, token 之后可以在view中指定 认证器类名 处理认证过程的业务逻辑可以通过 重写方法来进行 1234567891011121314151617181920212223242526272829303132class ArticleDetailView(RetrieveAPIView, UpdateAPIView, DestroyAPIView): # 查询结果集 queryset = Articles.objects.all() # 序列化器类 serializer_class = ArticleSerializerForList # django 默认的主键形参为pk 如果改用其他 应通过 lookup_field 显试指定出来 lookup_field = &#x27;id&#x27; # 指定登录认证器 authentication_classes = [MyGeneralAuthentication] def get(self, request, *args, **kwargs): response = super().get(request, *args, **kwargs) # 此处验证是否登录 如果登录了 就可以更新浏览记录 if not request.auth: return response # 检查是否浏览记录已经存在 不用再添加了 # 拿到该文章所有的浏览记录 id = kwargs.get(&#x27;id&#x27;) article = Articles.objects.filter(id=id).first() user = request.user if user in [u for u in article.viwers.all()]: return response # 向中间表添加数据 也就是浏览记录 article.viwers.add(user) return response celery的使用123pip install celerypip install redispip install eventlet # eventlet 只有windows下才需要安装 linux不需要安装 12345678910111213141516from celery import Celery&quot;&quot;&quot;broker 指定任务队列backend 指定结果队列&quot;&quot;&quot;app = Celery(&#x27;tasks&#x27;, backend=&#x27;redis://localhost:6379/0&#x27;, broker=&#x27;redis://localhost:6379/0&#x27;)&quot;&quot;&quot;使用 @app.task 装饰后就成为了一个 可以被celery调度的任务&quot;&quot;&quot;@app.taskdef add(x, y): return x + y 123456789101112from test import addimport time#不要直接 add(4, 4)，这里需要用 celery 提供的接口 delay 进行调用result = add.delay(4, 4) print(result.id)# 可以通过 reslut.ready() 判断add这个task是否处理结束while not result.ready(): time.sleep(1)# 可以通过 result.get() 来获取task的结果print(f&#x27;task done: &#123;result.get()&#125;&#x27;) 注意：worker 的启动命令celery worker -A taskproj -l info -P eventlet只有windows平台需要指定 -P eventlet 在linux下不需要 celery 与 django 嵌入使用django 项目名为： miniprogramapi 项目同名目录 miniprogramapi 创建的app名称为 testcelery 在项目的同名目录下创建celery.py文件 miniprogramapi&#x2F;miniprogramapi&#x2F;celery.py 文件名必须为 celery.py 固定不能变 123456789101112import osfrom celery import Celery# 设置django环境os.environ.setdefault(&#x27;DJANGO_SETTINGS_MODULE&#x27;, &#x27;miniprogramapi.settings&#x27;)app = Celery(&#x27;testcelery&#x27;)# 使用CELERY_ 作为前缀，在settings中写配置app.config_from_object(&#x27;django.conf:settings&#x27;, namespace=&#x27;CELERY&#x27;)# 发现任务文件每个app下的task.pyapp.autodiscover_tasks() 在项目的同名目录下 __init__.py 文件中添加内容 123from .celery import app as celery_app__all__ = [&#x27;celery_app&#x27;] 在项目同名文件夹 settings.py 中添加关于 celery的配置 1234567# ******************************* celery的配置 ***************************# Broker配置，使用Redis作为消息中间件CELERY_BROKER_URL = &#x27;redis://127.0.0.1:6379/0&#x27;# BACKEND配置，这里使用redisCELERY_RESULT_BACKEND = &#x27;redis://127.0.0.1:6379/0&#x27;# 结果序列化方案CELERY_RESULT_SERIALIZER = &#x27;json&#x27; 在创建的app中定义 tasks.py 文件 文件名必须叫 tasks.py 1234567891011from celery import shared_task@shared_taskdef add(x, y): return x + y@shared_taskdef mul(x, y): return x * y 启动 worker的命令 1celery worker -A miniprogramapi -l info -P eventlet 编写urls 12345678910111213from django.urls import pathfrom testcelery.views import TestCelery, ResultCeleryapp_name = &#x27;testcelery&#x27;urlpatterns = [ # 执行触发celery task path(&#x27;celery/&#x27;, TestCelery.as_view(), name=&#x27;celery&#x27;), # 查询celery task的执行结果 path(&#x27;result/&#x27;, ResultCelery.as_view(), name=&#x27;result&#x27;),] 编写视图 1234567891011121314151617181920212223242526272829# Create your views here.from celery.result import AsyncResultfrom rest_framework.response import Responsefrom rest_framework.views import APIViewfrom miniprogramapi import celery_appfrom testcelery import tasksclass TestCelery(APIView): def get(self, request, *args, **kwargs): res = tasks.add.delay(1, 3) # 任务逻辑 data = &#123;&#x27;status&#x27;: &#x27;successful&#x27;, &#x27;task_id&#x27;: res.task_id&#125; return Response(data)class ResultCelery(APIView): def get(self, request, *args, **kwargs): result_id = request.query_params.dict().get(&#x27;result_id&#x27;) # result_id = &#x27;1f9b12da-f4da-4562-a6d1-ad2d7e18d86b&#x27; result_obj = AsyncResult(id=result_id, app=celery_app) data = &#123; &#x27;status&#x27;: 1, &#x27;state&#x27;: result_obj.state, &#x27;result&#x27;: result_obj.get() &#125; return Response(data) 扩展 除了redis、rabbitmq能做结果存储外，还可以使用Django的orm作为结果存储，当然需要安装依赖插件，这样的好处在于我们可以直接通过django的数据查看到任务状态，同时为可以制定更多的操作，下面介绍如何使用orm作为结果存储。 安装 1pip install django-celery-results 配置settings.py，注册app 1234INSTALLED_APPS = ( ..., &#x27;django_celery_results&#x27;,) 修改backend配置，将redis改为django-db 123# CELERY_RESULT_BACKEND = &#x27;redis://127.0.0.1:6379/0&#x27; # BACKEND配置，这里使用redisCELERY_RESULT_BACKEND = &#x27;django-db&#x27; #使用django orm 作为结果存储 修改数据库 1python3 manage.py migrate django_celery_results","path":"2022/07/15/使用drf框架编写api/","date":"07-15","excerpt":"","tags":[]},{"title":"linux配置jdk","text":"sudo vim &#x2F;etc&#x2F;profile 1234#Java Envexport JAVA_HOME=/usr/local/jdkexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin source &#x2F;etc&#x2F;profile","path":"2022/07/15/linux配置jdk/","date":"07-15","excerpt":"","tags":[]},{"title":"django在linux上部署","text":"目录结构 nginx配置文件 nginx.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /usr/local/nginx/conf/mime.types; default_type application/octet-stream; #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; root /home/abel/code/website; location /static &#123; alias /home/abel/code/website/static; &#125; location / &#123; include /usr/local/nginx/conf/uwsgi_params; uwsgi_pass 127.0.0.1:8011; &#125; &#125;&#125; uwsgi配置文件 uwsgi.ini (django)1234567891011121314[uwsgi]# 使用nginx反向代理时使用;socket = 127.0.0.1:8011# 直接作为web服务器使用 记得host一定要是0.0.0.0http = 0.0.0.0:8010# 配置工程目录chdir = /tmp/pycharm_project_368# 配置项目的wsgi目录 注意是相对于工程目录 wsgi.py 文件时django框架自动生成的wsgi-file = testdjango/wsgi.py# 配置虚拟环境;home = /root/.venvs/py38# 配置进程线程的信息processes = 1threads = 1 uwsgi配置文件 uwsgi.ini (flask)1234567891011121314151617[uwsgi]#uwsgi启动时，所使用的地址和端口（这个是http协议的）http = 0.0.0.0:5001# 虚拟环境路径virtualenv = /root/.venvs/py38#指向网站目录chdir = /tmp/pycharm_project_697#python 启动程序文件wsgi-file = myflask.py#python 程序内用以启动的application 变量名callable = app#处理器数processes = 4#线程数threads = 2 注意：flask程序中 app.run(host&#x3D;’0.0.0.0’) host 一定要写 要不然远程访问不了 uwsgi 相关命令 进入虚拟环境 安装uwsgi 1pip install uwsgi 测试uwsgi，创建test.py文件： 123def application(env, start_response): start_response(&#x27;200 OK&#x27;, [(&#x27;Content-Type&#x27;,&#x27;text/html&#x27;)]) return [b&quot;Hello World&quot;] 1uwsgi --http :8001 --wsgi-file test.py 停止 uwsgi --stop /home/abel/code/website/uwsgi.pid 开启 （一定要先进入虚拟环境） uwsgi --ini /home/abel/code/website/uwsgi.ini nginx 相关命令 关闭 sudo nginx -s quit 重新加载配置文件 sudo nginx -s reload 测试配置文件 sudo nginx -t -c /home/abel/code/website/nginx.conf 启动 sudo nginx -c /home/abel/code/website/nginx.conf 查看服务是否活着 ps -ef | grep nginx","path":"2022/07/15/django在linux上部署/","date":"07-15","excerpt":"","tags":[]},{"title":"centos7图形界面和字符界面切换命令","text":"开机以命令模式启动，执行：systemctl set-default multi-user.target 开机以图形界面启动，执行：systemctl set-default graphical.target","path":"2022/07/15/centos7图形界面和字符界面切换命令/","date":"07-15","excerpt":"","tags":[]},{"title":"allure制定清晰的pytest测试报告","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344import allureimport pytest# feature() 给功能模块取个名字 一个功能模块包含多个功能点 一般一个功能模块就作为一个类@allure.feature(&#x27;购物车功能&#x27;)class TestShoppingTrolley: # story() 给功能点取个名字 一般一个功能点就作为一个方法 @allure.story(&#x27;加入购物车&#x27;) def test_add_shopping_trolley(self): # 步骤1 因为login() 被装饰器 @allure.step()装饰过 报告中会将步骤详细展示出来 login(&#x27;刘春明&#x27;, &#x27;密码&#x27;) # 步骤2 with allure.step(&quot;浏览商品&quot;): # attach() 添加文本信息到报告中 allure.attach(&#x27;笔记本&#x27;, &#x27;商品1&#x27;) allure.attach(&#x27;手机&#x27;, &#x27;商品2&#x27;) # attach() 添加截图信息到报告中 with open(&#x27;./商品3截图.png&#x27;, &#x27;rb&#x27;) as f: file = f.read() allure.attach(file, &#x27;商品3&#x27;, allure.attachment_type.PNG) # 步骤3 with allure.step(&quot;点击商品&quot;): pass # 步骤4 with allure.step(&quot;校验结果&quot;): allure.attach(&#x27;添加购物车成功&#x27;, &#x27;期望结果&#x27;) allure.attach(&#x27;添加购物车失败&#x27;, &#x27;实际结果&#x27;) assert &#x27;success&#x27; == &#x27;failed&#x27; @allure.story(&#x27;修改购物车&#x27;) def test_edit_shopping_trolley(self): pass @pytest.mark.skipif(reason=&#x27;本次不执行&#x27;) @allure.story(&#x27;删除购物车中商品&#x27;) def test_delete_shopping_trolley(self): pass@allure.step(&#x27;用户登录&#x27;)def login(user, pwd): print(user, pwd) 12pytest cases\\test_allure2.py --alluredir ./result/allure generate ./result -o ./report --clean","path":"2022/07/15/allure制定清晰的pytest测试报告/","date":"07-15","excerpt":"","tags":[]},{"title":"centos7安装python3.8","text":"0. 安装gcc 、c++编译器以及内核文件1yum -y install gcc gcc-c++ kernel-devel 1. 安装最新版openssl12sudo ./config --prefix=/usr/local/opensslsudo make &amp;&amp; sudo make install 安装好之后进行配置 备份原来的openssl命令mv &#x2F;usr&#x2F;bin&#x2F;openssl &#x2F;usr&#x2F;bin&#x2F;openssl.bak将安装好的bin目录中的openssl文件软连到&#x2F;usr&#x2F;bin&#x2F;opensslln -s &#x2F;usr&#x2F;local&#x2F;openssl&#x2F;bin&#x2F;openssl &#x2F;usr&#x2F;bin&#x2F;openssl将安装好的openssl 的openssl目录软连到&#x2F;usr&#x2F;include&#x2F;opensslln -s &#x2F;usr&#x2F;local&#x2F;openssl&#x2F;include&#x2F;openssl &#x2F;usr&#x2F;include&#x2F;openssl修改系统自带的openssl库文件，如&#x2F;usr&#x2F;local&#x2F;lib64&#x2F;libssl.so(根据机器环境而定) 软链到升级后的libssl.soln -s &#x2F;usr&#x2F;local&#x2F;openssl&#x2F;lib&#x2F;libssl.so.1.1 &#x2F;usr&#x2F;local&#x2F;lib64&#x2F;libssl.so —-注意时usr&#x2F;local下的lib64不是&#x2F;usr&#x2F;lib64，两个目录下有同名目录，有可能在&#x2F;usr&#x2F;local&#x2F;lib64&#x2F;并不存在文件在&#x2F;etc&#x2F;ld.so.conf文件中写入openssl库文件的搜索路径echo “&#x2F;usr&#x2F;local&#x2F;related&#x2F;openssl&#x2F;lib” &gt;&gt; &#x2F;etc&#x2F;ld.so.conf使修改后的&#x2F;etc&#x2F;ld.so.conf生效ldconfig -v最好查看下openssl版本号，看是否已经更新成最新的，openssl version -a 2. 安装python3.812sudo ./configure --prefix=/usr/local/python38 --enable-shared --with-openssl=/usr/local/opensslsudo make &amp;&amp; sudo make install 安装过程中的报错处理报gcc错误yum -y install gcc报zlib错误yum -y install zlib*报 ‘_ctypes’的错误。yum install libffi-devel -y 3. 建立软连接方便使用12sudo ln -s /usr/local/python38/bin/python3.8 /usr/bin/python38sudo ln -s /usr/local/python38/bin/pip3.8 /usr/bin/pip38 4. pip换源 ~&#x2F;.pip&#x2F;pip.conf123456[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host = mirrors.aliyun.com[list]format=columns 5. 安装virtualenvwrapper1sudo pip38 install virtualenvwrapper 可能会报错 动态库错误 拷贝一下就行了error while loading shared libraries: libpython3.8m.so.1.1:cannot open shared object file: No such file or directory 1cp /usr/local/python38/lib/libpython3.8.so.1.0 /usr/lib64/ 6. 配置virtualenvwrapper12345WORKON_HOME=~/.venvsVIRTUALENVWRAPPER_VIRTUALENV_ARGS=&#x27;--no-site-packages&#x27;VIRTUALENVWRAPPER_PYTHON=/usr/local/python38/bin/python3.8export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/python38/bin/virtualenvsource /usr/local/python38/bin/virtualenvwrapper.sh 在 ~&#x2F;.bashrc 中写入上面内容source ~&#x2F;.bashrc 使其生效 7. 创建虚拟环境1mkvirtualenv py38 如果报 ‘–no-site-packages’ 无效的不能识别的参数 错误则需要更新virtualenv 1sudo pip38 install --upgrade virtualenv==16.7.9","path":"2022/07/15/centos7安装python3-8/","date":"07-15","excerpt":"","tags":[]},{"title":"jmeter调用jar包","text":"1. 导出jar包 jar包内部逻辑代码如下：（模拟加盐） 2. 将jar包导入jmeter 3. 添加 BeanShell取样器 1234567// 导入jar包import com.abel.Test;String param = &quot;rose&quot;;// 调用jar包中的方法String res = Test.GetMD5(param);// 将结果赋值给jmeter中的变量进行引用vars.put(&quot;res&quot;,res) 4. 在请求中使用该变量 5. 最终jmter就可以调用通过jar包计算出的结果了","path":"2022/07/15/jmeter调用jar包/","date":"07-15","excerpt":"","tags":[]},{"title":"性能测试监控方案02","text":"所需的插件包和收集器 将插件包解压在 lib&#x2F;ext目录下 将ServerAgent收集器上传到需要被监控的机器，解压，启动 （linux启动startAgent.sh win启动startAgent.bat） 开启被监控机器的【4444】端口进行监听 Jmeter中启用 【PerfMon Metrics Collector】元件 进行监控 【PerfMon Metrics Collector】元件配置如下 6. 启动脚本给被监控机器负载一定压力，效果就出来了。","path":"2022/07/15/性能测试监控方案02/","date":"07-15","excerpt":"","tags":[]},{"title":"性能测试监控方案","text":"node_exporter+prometheus+grafana利用Jmeter做性能测试的时候，通常使用的是 ServerAgent的资源监控方案，但ServerAgent图表实在是太丑了。于是乎发现了node_exporter+prometheus+grafana这种监控组合，当然主要是借助grafana漂亮的图表。 node_exporter （采集数据） prometheus （存储数据） grafana （展示数据） 本文所使用的安装包如下： 安装go语言环境 由于prometheus是go语言开发的，所以需要提前安装好go语言环境。root@archive soft]# tar -C &#x2F;usr&#x2F;local -xzf go1.8.3.linux-amd64.tar.gz [root@archive soft]# vim &#x2F;etc&#x2F;profile 在文件的最后添加如下内容： export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin 保存退出后，接着让配置文件立刻生效： [root@archive aiops]# source &#x2F;etc&#x2F;profile 验证一下是否成功，用go version 来验证 [root@archive aiops]# go version go version go1.8.3 linux&#x2F;amd64 安装node_exporter1234sudo tar -zxvf node_exporter安装包.tar.gz -C /usr/local/cd /usr/local/node_exporter文件夹名lssudo ./node_exporter node_exporter启动后默认会通过9100端口向外（prometheus）发送数据。 安装prometheus1234sudo tar -zxvf prometheus安装包.tar.gz -C /usr/local/cd /usr/local/prometheus文件夹名lssudo ./prometheus 修改prometheus.yml文件，接收node_exoprter采集到的资源数据。修改后重新启动prometheus 在目标机器IP:9090&#x2F;metrics 可以打开prometheus的监控界面 安装grafana1sudo yum localinstall grafana安装包.rpm 为grafana添加数据源ip:3000端口可以打开 监控界面 默认的账号密码为：admin&#x2F;admin 第一次成功登录后会要求修改密码 https://grafana.com/grafana/dashboards/8919?src=grafana_search在prometheus中切换dashboard至上面安装好的仪表盘：最终效果就出现了。 最终监控面板效果：","path":"2022/07/15/性能测试监控方案/","date":"07-15","excerpt":"","tags":[]},{"title":"hexo上传图片","text":"开启图片文件夹 12# _config.ymlpost_asset_folder: true 安装图片插件 1npm install hexo-asset-image --save 2.1 整个替换该插件中的index.js内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register(&#x27;after_post_render&#x27;, function (data) &#123; var config = hexo.config; if (config.post_asset_folder) &#123; var link = data.permalink; var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; var appendLink = &#x27;&#x27;; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. // if not with index.html endpos = link.lastIndexOf(&#x27;.&#x27;) + 1 support hexo-abbrlink if (/.*\\/index\\.html$/.test(link)) &#123; // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html // image in xxtitle/ will go to xxtitle/index/ appendLink = &#x27;index/&#x27;; var endPos = link.lastIndexOf(&#x27;.&#x27;); &#125; else &#123; var endPos = link.lastIndexOf(&#x27;/&#x27;); &#125; link = link.substring(beginPos, endPos) + &#x27;/&#x27; + appendLink; var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for (var i = 0; i &lt; toprocess.length; i++) &#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function () &#123; if ($(this).attr(&#x27;src&#x27;)) &#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if (!(/http[s]*.*|\\/\\/.*/.test(src) || /^\\s+\\//.test(src) || /^\\s*\\/uploads|images\\//.test(src))) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function (elem) &#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function (elem) &#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if (srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); $(this).attr(&#x27;src&#x27;, config.root + link + src); console.info &amp;&amp; console.info(&quot;update link as:--&gt;&quot; + config.root + link + src); &#125; &#125; else &#123; console.info &amp;&amp; console.info(&quot;no src attr, skipped...&quot;); console.info &amp;&amp; console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 创建文章 1hexo new &quot;hexo上传图片&quot; 将图片放到md文件的同名文件夹中 引用图片 1![](hexo上传图片/1.png) 生成推送看效果 1hexo g -d","path":"2022/07/08/hexo上传图片/","date":"07-08","excerpt":"","tags":[]},{"title":"git培训讲义","text":"GIT培训讲义 作者：程义军 时间：2022-07-06 1 为什么是GIT而不是SVN SVN由于是集中式的架构，一旦中央仓库服务器宕机，版本控制工作就彻底失效；GIT是分布式的，每个工作节点都有相对完整的仓库备份，远程仓库离线也不影响正常的版本控制工作。 SVN绝大部分操作都要请求网络，版本回退或者切换分支比较慢；GIT大部分操作是基于本地的，版本回退或者切换分支非常快（只是移动了Head指针）。 便于和Jenkins之类的CI/DI测试工作流软件进行集成，进行高效的自动化测试与部署。 GIT对于文件的存储进行了优化，大幅降低了存储空间占用。 2 git的工作流图 3 git的基本操作 clone 12# 克隆已经存在的版本库git clone http://192.168.10.141:9980/cyj/tp03.git checkout 1234567# 作用1 创建分支git checkout -b branchName [commitID / tagName]# 作用2 切换分支git checkout branchName# 作用3 丢弃工作区改动git checkout .git checkout -- fileName add 123# 向暂存区添加改动git add .git add fileName commit 12# 向暂存区提交已经添加进来的改动git commit -m &quot;变更说明&quot; pull 12# 从远端分支获取改动 并与当前分支合并git pull origin main:main fetch （fetch+merge&#x3D;pull） 12345# 从远端分支获取改动 不主动与当前分支合并git fetch origin main:tmp# 常见的后续操作git diff tmpgit merge tmp merge 1# 见上一条 push 123456789101112# 向远端提交本地分支的改动git push origin main:main# **重要** 只要是改动远端分支都离不开push# 将指定的标签上传到远程仓库git push origin tagName # 将所有不在远程仓库中的标签上传到远程仓库git push origin --tags # 删除远端标签git push origin :V1.0.2# 删除远程分支git push origin :branchName status 12# 查看当前分支的状态git status log 12345# 查看提交历史git log --oneline --graph# 查看reset之前的历史git reflog diff 1# 作用见第六条 init 12# 将某个文件夹变为一个仓库 （本地先创建版本库 再往远端推送会用到）git init . 4 git进阶操作 丢弃工作区的改动 1234# 丢弃所有改动git checkout .# 丢弃单个文件的改动git checkout -- fileName 丢弃暂存区的记录 1234# 丢弃所有记录git restore --staged .# 丢弃单个记录git restore --staged fileName 从本地仓库撤销提交 （commit 逆向操作） 12345git revert commitID# 那么问题来了 他与上面讲的版本回退有什么区别呢git reset --hard commitID# 见下图 revert反向commit会有一个新的commit生成 可以回溯你撤销的历史 而reset则不会生成新的commit 时光机（版本回退） 123456789git reset --hard commitID # 回退版本 并将改动彻底丢弃 （推荐使用）git reset --soft commitID # 回退版本 并将改动撤回到暂存中 (回归的状态：已add未commit)git reset --mixed commitID # 回退版本 并将改动撤回到工作区中 mixed为缺省参数 （回归的状态：未add未commit）# 一些特殊的简写 (相对于当前Head指针回退一个版本)git reset --hard Head^git reset --hard Head~1 合并别人的代码（解决冲突） 所谓冲突是指两个不同commit对同一个文件的同一行进行了不同操作 1234# 合并之前查看分支差异git diff branchName# 根据差异解决冲突 然后再合并git merge branchName 本地和远端同一个文件的同一行存在差异 则会产生冲突，以下是冲突的直观展示： git fetch git diff origin/main 或者IDE里面可以观察到： Tag打标发布版本（版本冻结 打包归档） 所谓Tag其实就是一种特殊的Branch，主要作用为冻结版本，进行正式版本发布 12345678910111213141516171819202122232425262728293031# 创建taggit tag -a V1.0.1 -m &quot;message&quot;# 查看所有标签git tag -l# 查看标签详细信息git show tagName# 将指定的标签上传到远程仓库git push origin tagName # 将所有不在远程仓库中的标签上传到远程仓库git push origin --tags # 删除本地标签git tag -d V1.0.2# 删除远端标签git push origin :V1.0.2# 根据标签打包git archive V1.0.1 --format=zip --output=V1.0.1.zip# 支持的打包格式git archive --listtartgztar.gzzip# 根据标签创建对应的发版分支git checkout -b newBranchName tagName 分支操作 123456789101112131415161718192021# 创建分支git branch branchNamegit checkout -b branchNamegit push origin branchName:branchName# 查看分支git branch # 查看本地分支git branch -a # 查看本地分支+远程分支# 删除分支git branch -d branchName # 删除本地分支git branch -D branchName # 删除本地分支（强制）git push origin :branchName # 删除远程分支git push origin --delete branchName # 删除远程分支# 通过fetch获取更新创建分支git fetch origin main:tmp# 通常的后续操作git diff tmpgit merge tmpgit branch -d tmp 5 git的高阶操作 当你正在开发的功能开发了一半，此时来了紧急任务修复重大BUG，你该怎么做？（git stash） 由于功能开发了一半不好提交，但是由于有未提交的文件改动存在，无论是拉取远端，还是切换分支等操作均是做不到的。 123456789101112131415161718# 临时存储改动git stash save &quot;这里是开发了一半的影像中心功能&quot;# 正常 拉取远端代码 修改buggit pull# 修改bug# bug修改完毕了# 恢复临时改动git stash pop stash@&#123;0&#125;# 继续开发影像中心功能...# 删除临时改动git stash drop stash@&#123;0&#125;# 查看所有的临时存储git stash list 当你的个人的个人开发分支A与同事的开发分支B分离比较久了，同事已经修复了一个重大BUG，你也想在你的feature发布前获取这个修复，你该怎么做？ 12# 精确获取其他分支上的指定commit到本分支 并形成一个新的提交git cherry-pick commitID 那么问题来了，git merge 与 git cherry-pick 有什么区别呢？ 可以简单理解为：get merge 是我要别人所有的提交（all in了）；git cherry-pick是我需要别人某一个特定的提交 我把别人远端代码推挂了 我该怎么办？ 12345678# 远端代码回退# 首先回退本地对应分支代码到指定commitgit reset --hard commitID# 强推使远端分支与本地分支对齐# 此处必须强推 因为当前分支由于回退过 所以是落后对应的远端分支n个提交的 具体落后几个可以使用git status 查看到git push origin dev:dev -f 放弃追踪一些文件或者目录 12345678# 有的时间想要查看一下git跟踪了哪些文件，此命令就可以列出所有git正在跟踪的文件git ls-files# git不再跟踪名为FileName的文件，但是文件保留在工作区和暂存区中，也就是你的目录中git rm --cached FileName# 删除名为FileName的文件，同时git不再跟踪它git rm FileName 强制拉取远端代码 注意这种操作会覆盖掉本地代码 123456789# 获取远端的更新git fetch --all# 撤销本地、暂存区、版本库(用远程服务器的origin/master替换本地、暂存区、版本库) 强制进度指针对齐git reset --hard origin/master# 从远程仓库&quot;同步&quot;代码git pull origin master# 或单条执行：git fetch --all &amp;&amp; git reset --hard origin/master &amp;&amp; git pull 6 常见的难以理解的点 fast-forward的作用 rebase变基 注意变基与合并的区别 首先通过简单的提交节点图解感受一下rebase在干什么 两个分支master和feature，其中feature是在提交点B处从master上拉出的分支 master上有一个新提交M，feature上有两个新提交C和D 1234567891011git switch featuregit rebase master# 以上两句等价于 (可以简单理解为：将master里的commit 放到 feature上)git rebase master feature# 如果提示有冲突就解决冲突...# 解决冲突后继续变基git rebase --continue 原理说明： 7 一些规范 git默认的主分支：master分支名已经弃用 现在都叫main分支 由于黑人开发者的增多，鉴于黑人被种族歧视的历史（Master-Slave），黑人对git中的默认master分支提出抗议，2020年6月8日 Scott 发文呼吁将你的Git默认分支从master修改为main，目前国外各大主流软件商均已更改，Github也已弃用master改用main分支名，以示尊重。 大公司一般通用的简单分支模型 main分支：只用来打标TAG 用户版本代码冻结 进行发版dev分支：用来正常开发 迭代commitfeature分支：用来开发新功能，新功能开发完毕之后向dev合并bug分支：类似feature分支 进行bug修复 修复后向dev合并 .gitignore文件必须写 .gitignore文件必须写，指定无需提交的文件及文件夹 如：ide的配置 编译产生的中间产物 第三方依赖库 都需要忽略 8 git与gitlab的配套使用 先在gitlab创建空白仓库再克隆 注意：将仓库地址进行一个替换 如下： http://6c4c5ae0240e/cyj/tp03.githttp://192.168.10.141:9980/cyj/tp03.git git clone http://192.168.10.141:9980/cyj/tp03.git 针对本地 已经存在的项目 推送到gitlab 进入项目目录 执行git init . 初始化仓库 在gitlab上创建仓库 如果勾选了，会报出如下错误： 1234cd existing_repogit remote add origin http://192.168.10.141:9980/cyj/tp03.git # 指定远程仓库的位置git branch -M main # 将当前分支重命名为main （gitlab默认就会创建main作为主分支 作为对应远程分支）git push -uf origin main # -u表示--set-upstream和远程仓库建立映射关系 其实等价于 git push origin main:main 关于项目成员推送提交 默认是需要项目仓库所有者自己审核PR 如果想取消可以进行如下操作： 如果向远端推送，提示换行符警告，可以执行自动转换命令 123456789101112131415161718192021222324252627# 补充知识win： CRLF =&gt; &quot;\\r\\n&quot;Linux: LF =&gt; &quot;\\n&quot;# 补充知识Git命令行修改AutoCRLF提交时转换为LF，检出时转换为CRLF（推荐windows）git config --global core.autocrlf true提交时转换为LF，检出时不转换（推荐*unix/mac）git config --global core.autocrlf input提交检出均不转换git config --global core.autocrlf falseGit命令行修改SafeCRLF拒绝提交包含混合换行符的文件git config --global core.safecrlf true允许提交包含混合换行符的文件git config --global core.safecrlf false提交包含混合换行符的文件时给出警告git config --global core.safecrlf warn# 推荐配置提交检出均不转换git config --global core.autocrlf false允许提交包含混合换行符的文件git config --global core.safecrlf false 频繁要求输入账号密码很烦，怎么解决？ 终端执行该命令 1git config --global credential.helper store 进行任意一种输需要身份验证的操作 如push pull等 输入一次正确的用户名和密码 检查你的用户目录下 会出现 .git-credentials 文件 打开后已经写入了用户名和密码 如下图所示 以后再不会要求输入用户名密码了","path":"2022/07/08/git培训讲义/","date":"07-08","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"https://chengyijun.github.io/tags/git/"}]}],"categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://chengyijun.github.io/tags/git/"}]}